---
title: "OAuth2.0"
categories:
  - Common
tags:
  - OAuth2.0
  - 인증
  - 인가
  - access token
  - authorization

---

 OAuth2.0은 authorization(클라이언트에게 권한부여)를 위한 표준이며 web, desktop, mobile application에 해당하는 클라이언트가 보다 간편한 authorization 작업 수행하는 것을 목적으로 합니다.

OAuth2.0은 authentication(클라이언트가 자신이 주장하는 사용자와 같은 사용자인지를 확인)를 담당하지 않으며 authentication 대체로 HTTPS를 통해 이뤄집니다.

## 언제 OAuth2.0을 사용하게 될까요?

첫번째, 사용자에게 얻고자 하는 데이터를 가진 서비스가 있고 그 서비스가 OAuth2.0 기반의 API를 제공하는 경우입니다.
예를들어 '구글로 로그인하기'를 나의 서비스에 구현하길 원한다면 구글에 나의 서비스를 등록하고 원하는 사용자 데이터를 얻을 수 권한을 신청합니다. 이후 OAuth2.0 절차에 따라 사용자 데이터를 요청하는 과정을 수행합니다.

두번째, 나의 서비스에 authorization를 구현하고 싶은 경우 OAuth2.0 기반하여 개발할 수 있습니다. 최종적으로 나의 서비스 사용자 요청이 권한에 맞게 요청된 것인지 확인합니다.


## OAuth2.0을 한장의 그림으로 설명해주세요

### OAuth2.0의 구성원

리소스 소유자: 일반적으로 생각하는 브라우저, 모바일을 통해 서비스를 사용하는 여러분이다

인가서버:

클라이언트: 보호된 리소스를 API를 통해 얻으려는 소프트웨어

보호된 리소스: 웹 API 형태를 띠고 클라이언트가 가진 권한에 따라 데이터를 제공한다 

브라우저:


### OAuth2.0 구성 요소

token
 OAuth는 토큰의 포맷이나 내용을 정의하지 않지만 클라이언트가 요청한 접근 권한, 리소스 소유자의 클라이언트 인가, 클라이언트에게 부여된 권한을 토큰으로 알수 있다

scope
보호된 리소스에 대한 접근 권한을 나타낸다. 범위는 공백으로 구분된 범위 문자열의 조합으로 표현된다. 따라서 범위를 나타내는 문자열에는 공백이 포함되면 안된다. 하지만 범위값으 ㅣ포맷과 구조가 0Auth 스펙에 정의된 것은 아니다

Authorization Grant


## OAuth2.0 Authrization Grant


### Authrization Code Grant

리소스 소유자가 클라이언트에게 접근 권한을 위임했다는 것을 나타내기 위해 임시 자격 증명인 인가 코드를 사용한다



그림 2.6 
 클라이언트가 인가 코드를 획득하면 그것을 다시 client id, client secret과 함께 인가 서버의 토큰 엔드 포인트로 전달한다.
 인가 서버는 자신에게 전달된 요청이 올바른 요청인지 확인하기 위해 3 단계에 걸쳐 확인한다
첫번째, 어느 클라이언트가 접근 권한을 요청했는지 판단하고 위해 Authorization header로 전달된 클라이언트 자격 증명 데이터를 확인한다
두번째, code 파라미터를 읽어 인가 코드와 연관된 정보를 확인한다(어느 사용자가 인가했는지 & 무엇을 인가했는지)
세번째, 인가 코드가 유효하고 이전에 사용된 적이 없으며 질의를 요청한 클라이언트가 원래 권한을 요청한 클라이언트와 같다고 판단도면 access token을 발급하아여 JSON 형태로 HTTP 응답에 포함하여 전달한다

그림 2.7
토큰 응답 안에는 토큰 타입, 리프레시 토큰(권한 위임을 다시 받지 않고 새로운 엑세스 토큰을 얻기 위해 사용), 토큰의 권한 범위, 만료시간 등 정보가 있다

그림 2.8
보호된 리소스는 헤더에서 전달된 토큰을 추출하여 유효한 것인지 확인, 누가 인가 했는지, 무엇을 인가했는지를 확인한다.
보호된 리소스가 토큰을 확인하기 위한 검색에는 여러 가지 선택 중 선택할 수 있으며 11장에 자세히 알아본다
가장 간단한 방법은 토큰 정보를 담고 있는 데이터베이스를 리소스 서버와 인가서버가 공유하도록 하는 것이다. 인가 서버는 새로운 토큰이 만들어지면 그것을 저장소에 저장하고 리소스 서버는 저장소에서 토큰을 읽어 전달된 토큰을 사용한다


## 메모
p36 클라이언트 애플리케이션은 리소스 소유자(일반적으로 엔드 유저)를 대신해 리소스 소유자의 보호된 리소스에 대한 접근 권한을 얻길 원한다

p59 인가 코드 그랜트: 인가 코드 그랜트는 리소스 소유자가 클라이언트에게 접근 권한을 위임했다는 것을 나타내기 위해 일회용으로 사용되며 임시 자격 증명인 인가 코드를 사용한다. 

p59 OAuth는 유연성을 최대한 유지하기 위해 실제 API 시스템의 세부적인 내용까지 정의하지 않느다

p59 OpenID 커넥트와 UMA와 같은 OAuth 위에서 동작하는 프로토콜이 있다

p63 사용자의 인증 정보는 사용자와 인가 서버간 직접 전달 된다. 클라이은트 애플리케이션은 관여할 수 없고 사용자 인증 정보를 볼 수 없다.

p63 인가 서버는 ID/PW 외에도 인증서, 보안 토큰, SSO 등 다양한 인증 기술을 사용할 수 있다

p64 대부분 인가 서버는 리소스 소유자의 인가 결정 내용을 이후에도 그대로 유지되도록 저장할 수 있게 도와준다 그리면 이후 동일한 클라이언트에 의한 접근 권한 요청에 대해 사용자가 다시 판단해 결정하지 않아도 된다. 그런 경우에도 사용자는 여전히 인가 엔트 포인트로 라다이렉트되고, 로그인이 필요하지만 클라이언트에 대한 권한 위임은 이미 이전에 이뤄졌기 때문에 다시 하지 않아도 된다.

p66 지금 인가 코드 그랜트 유형을 이용하고 있기 때문에.. 

p68 Bearer은 특별한 보안 속성을 갖고 있으며 10장에서 다룬다